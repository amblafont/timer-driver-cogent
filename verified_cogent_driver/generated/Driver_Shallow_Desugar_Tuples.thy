(*
This file is generated by Cogent

*)

theory Driver_Shallow_Desugar_Tuples
imports "Driver_ShallowShared_Tuples"
begin

definition
  reset_timer_e :: " Meson_timer_reg\<^sub>T \<Rightarrow>  Meson_timer_reg\<^sub>T"
where
  "reset_timer_e ds\<^sub>0 \<equiv>
    ds\<^sub>0 \<lparr>
      Meson_timer_reg.timer_e\<^sub>f :=
        (0 :: 32 word),
      Meson_timer_reg.timer_e_hi\<^sub>f :=
        (0 :: 32 word)
      \<rparr>"

definition
  initialize :: " Meson_timer\<^sub>T \<Rightarrow>  Meson_timer\<^sub>T"
where
  "initialize ds\<^sub>0 \<equiv>
    let regs = Meson_timer.regs\<^sub>f ds\<^sub>0
    in ds\<^sub>0
        \<lparr>Meson_timer.regs\<^sub>f :=
          reset_timer_e (regs \<lparr>
            Meson_timer_reg.timer_a_input_clk\<^sub>f :=
              (Timeout_timebase.TIMEOUT_TIMEBASE_1_MS () ::  Timeout_timebase\<^sub>T),
            Meson_timer_reg.timer_e_input_clk\<^sub>f :=
              (Timestamp_timebase.TIMESTAMP_TIMEBASE_1_US () ::  Timestamp_timebase\<^sub>T)
            \<rparr>)\<rparr>"

definition
  meson_get_time :: " Meson_timer\<^sub>T \<Rightarrow> 64 word"
where
  "meson_get_time ds\<^sub>0 \<equiv>
    let initial_high = (ucast (Meson_timer_reg.timer_e_hi\<^sub>f (Meson_timer.regs\<^sub>f ds\<^sub>0)) :: 64 word);
      low = (ucast (Meson_timer_reg.timer_e\<^sub>f (Meson_timer.regs\<^sub>f ds\<^sub>0)) :: 64 word);
      high = (ucast (Meson_timer_reg.timer_e_hi\<^sub>f (Meson_timer.regs\<^sub>f ds\<^sub>0)) :: 64 word);
      low' = if (~=) high initial_high
        then (ucast (Meson_timer_reg.timer_e\<^sub>f (Meson_timer.regs\<^sub>f ds\<^sub>0)) :: 64 word)
        else low;
      ticks = (OR) (checked_shift shiftl high (32 :: 64 word)) low';
      time = (*) ticks (1000 :: 64 word)
    in time"

definition
  meson_set_timeout :: " Meson_timer\<^sub>T \<times> 16 word \<times> bool \<Rightarrow>  Meson_timer\<^sub>T"
where
  "meson_set_timeout ds\<^sub>0 \<equiv>
    let (ds\<^sub>1,timeout,periodic) = ds\<^sub>0;
      regs = Meson_timer.regs\<^sub>f ds\<^sub>1;
      regs' = regs \<lparr>
          Meson_timer_reg.timer_a_mode\<^sub>f :=
            periodic,
          Meson_timer_reg.timer_a\<^sub>f :=
            (ucast timeout :: 32 word)
          \<rparr>;
      ds\<^sub>5 = Meson_timer.disable\<^sub>f ds\<^sub>1
    in if ds\<^sub>5
      then ds\<^sub>1 \<lparr>
          Meson_timer.regs\<^sub>f :=
            regs'
              \<lparr>Meson_timer_reg.timer_a_en\<^sub>f :=
                True\<rparr>,
          Meson_timer.disable\<^sub>f :=
            False
          \<rparr>
      else ds\<^sub>1
          \<lparr>Meson_timer.regs\<^sub>f :=
            regs'\<rparr>"

definition
  meson_stop_timer :: " Meson_timer\<^sub>T \<Rightarrow>  Meson_timer\<^sub>T"
where
  "meson_stop_timer ds\<^sub>0 \<equiv>
    let regs = Meson_timer.regs\<^sub>f ds\<^sub>0
    in ds\<^sub>0 \<lparr>
        Meson_timer.regs\<^sub>f := regs
            \<lparr>Meson_timer_reg.timer_a_en\<^sub>f :=
              False\<rparr>,
        Meson_timer.disable\<^sub>f :=
          True
        \<rparr>"

end
